/**
 * auto key - supports de-CH and en-US keyboard emulation, enters keyboard sequences for you after unlocking with a PIN code
 * requires a DigiSpark and a rotary encoder
 */

#include "DigiKeyboard.h"

#define PIN_ENCODER_A 0
#define PIN_ENCODER_B 2
#define PIN_ENCODER_SWITCH 1

#define SEPARATOR_LEN 2
#define PIN_LEN 6
static const uint8_t pin[PIN_LEN] = {1,2,3,4,5,6}; // digits 0-9

static uint8_t state  = 0;
static uint8_t lang   = 0; // 0 is en-US, 1 is de-CH

static uint8_t enc_prev_pos = 0;
static uint8_t enc_flags    = 0;
static int8_t  enc_action   = 0; // 1 or -1 if moved, sign is direction

// menu 1
#define MENU1_LEN 8
const PROGMEM uint8_t menu1 [MENU1_LEN] = {
  0xe,  // k
  0x8,  // e
  0x1c, // y
  0x5,  // b
  0x12, // o
  0x4,  // a
  0x15, // r
  0x7   // d
};

#define MENU1_OPTIONS_LEN 10
const PROGMEM uint8_t menu1_options [MENU1_OPTIONS_LEN] = {
  0x8,   // e
  0x11,  // n
  0x2d,  // -
  0x18,  // U
  0x16,  // S

  0x7,   // d
  0x8,   // e
  0x38,  // -
  0x6,   // C
  0xb    // H
};

// menu 2
#define MENU2_LEN 3
const PROGMEM uint8_t menu2 [MENU2_LEN] = {
  0x13, // p
  0xc,  // i
  0x11  // n
};
static uint8_t menu2_count = 0;
static uint8_t menu2_selection = 0;

// menu 3
#define MENU3_LEN 2
//#define MENU3_LEN 3
// labels may be no longer then 25 characters and are all lower case keys
#define MENU3_LABEL_LEN 25
const PROGMEM uint8_t menu3_labels [MENU3_LEN][2][MENU3_LABEL_LEN] = {
  // credentials
  {
    // en-US
    {0xf, 0x1d, 0xf, 0x4, 0x5, 0x16, 0x2c, 0x6, 0x15, 0x8, 0x7, 0x8, 0x11, 0x17, 0xc, 0x4, 0xf, 0x16},
    // de-CH
    {0xf, 0x1c, 0xf, 0x4, 0x5, 0x16, 0x2c, 0x6, 0x15, 0x8, 0x7, 0x8, 0x11, 0x17, 0xc, 0x4, 0xf, 0x16}
  },
  // MacOS provisioning
  {
    // en-US
    {0xf, 0x1d, 0xf, 0x4, 0x5, 0x16, 0x2c, 0x10, 0x4, 0x6, 0x12, 0x16, 0x2c, 0x13, 0x15, 0x12, 0x19, 0xc, 0x16, 0xc, 0x12, 0x11, 0xc, 0x11, 0xa},
    // de-CH
    {0xf, 0x1c, 0xf, 0x4, 0x5, 0x16, 0x2c, 0x10, 0x4, 0x6, 0x12, 0x16, 0x2c, 0x13, 0x15, 0x12, 0x19, 0xc, 0x16, 0xc, 0x12, 0x11, 0xc, 0x11, 0xa}
  }/*,
  // Windows provisioning
  {
    // en-US
    {0xf, 0x1d, 0xf, 0x4, 0x5, 0x16, 0x2c, 0x1a, 0xc, 0x11, 0x7, 0x12, 0x1a, 0x16, 0x2c, 0x13, 0x15, 0x12, 0x19, 0xc, 0x16, 0xc, 0x12, 0x11, 0xc, 0x11, 0xa},
    // de-CH
    {0xf, 0x1c, 0xf, 0x4, 0x5, 0x16, 0x2c, 0x1a, 0xc, 0x11, 0x7, 0x12, 0x1a, 0x16, 0x2c, 0x13, 0x15, 0x12, 0x19, 0xc, 0x16, 0xc, 0x12, 0x11, 0xc, 0x11, 0xa}
  }*/
};
// keys may be no longer then 166 sequences and consist of a key press and a modifier value (2 bytes for 166 sequences = 332 bytes)
// a key of 0x0 causes the modifier byte to be interpreted as a delay in ms - for delays greater then 255ms use multiple delay sequences
// a key and modifier of 0x0 is regarded as the end of the sequence, in case of sequences smaller then 256 items
#define MENU3_KEY_LEN 332
//#define MENU3_KEY_LEN 470
const PROGMEM uint8_t menu3_keys [MENU3_LEN][2][MENU3_KEY_LEN] = {
  // credentials
  {
    // en-US
    {0xd, 0x0, 0x7, 0x0, 0x12, 0x0, 0x8, 0x0, 0x2b, 0x0, 0x1e, 0x0, 0x1f, 0x0, 0x20, 0x0, 0x13, 0x2, 0x1f, 0x2, 0x16, 0x0, 0x16, 0x0, 0x1a, 0x2, 0x12, 0x0, 0x15, 0x0, 0x7, 0x0, 0x1e, 0x2, 0x28, 0x0},
    // de-CH
    {0xd, 0x0, 0x7, 0x0, 0x12, 0x0, 0x8, 0x0, 0x2b, 0x0, 0x1e, 0x0, 0x1f, 0x0, 0x20, 0x0, 0x13, 0x2, 0x1f, 0x40, 0x16, 0x0, 0x16, 0x0, 0x1a, 0x2, 0x12, 0x0, 0x15, 0x0, 0x7, 0x0, 0x30, 0x2, 0x28, 0x0}
  },
  // MacOS provisioning
  {
    // en-US
    {
      0x2c, 0x8, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, // COMMAND + SPACE, delay 3 * 255ms
      0x17, 0x2, 0x8, 0x0, 0x15, 0x0, 0x10, 0x0, 0xc, 0x0, 0x11, 0x0, 0x4, 0x0, 0xf, 0x0, 0x0, 0xff, 0x0, 0xff, // "Terminal", delay 2 * 255ms
      0x28, 0x0, 0x0, 0xff, 0x0, 0xff, // ENTER, delay 2 * 255ms
      0x6, 0x0, 0x18, 0x0, 0x15, 0x0, 0xf, 0x0, 0x2c, 0x0, 0xb, 0x0, 0x17, 0x0, 0x17, 0x0, 0x13, 0x0, 0x16, 0x0, 0x33, 0x2, 0x38, 0x0, 0x38, 0x0, 0x13, 0x0, 0x4, 0x0, 0x6, 0x0, 0xe, 0x0, 0x4, 0x0, 0xa, 0x0, 0x8, 0x0, 0x16, 0x0, 0x2d, 0x0, 0xf, 0x0, 0xc, 0x0, 0x11, 0x0, 0x18, 0x0, 0x1b, 0x0, 0x37, 0x0, 0xf, 0x0, 0x1d, 0x0, 0xf, 0x0, 0x4, 0x0, 0x5, 0x0, 0x16, 0x0, 0x37, 0x0, 0x6, 0x0, 0x12, 0x0, 0x10, 0x0, 0x38, 0x0, 0xf, 0x2, 0x1d, 0x0, 0xf, 0x2, 0x4, 0x0, 0x5, 0x0, 0x16, 0x0, 0x38, 0x0, 0x4, 0x2, 0x11, 0x0, 0x16, 0x0, 0xc, 0x0, 0x5, 0x0, 0xf, 0x0, 0x8, 0x0, 0x38, 0x0, 0x16, 0x0, 0x8, 0x0, 0x17, 0x0, 0x18, 0x0, 0x13, 0x0, 0x2d, 0x2, 0x10, 0x0, 0x4, 0x0, 0x6, 0x0, 0x37, 0x0, 0x16, 0x0, 0xb, 0x0, 0x2c, 0x0, 0x2d, 0x0, 0x12, 0x0, 0x2c, 0x0, 0x38, 0x0, 0x17, 0x0, 0x10, 0x0, 0x13, 0x0, 0x38, 0x0, 0x16, 0x0, 0x8, 0x0, 0x17, 0x0, 0x18, 0x0, 0x13, 0x0, 0x2d, 0x2, 0x10, 0x0, 0x4, 0x0, 0x6, 0x0, 0x37, 0x0, 0x16, 0x0, 0xb, 0x0, 0x28, 0x0, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0x0, 0x6, 0x0, 0xb, 0x0, 0x10, 0x0, 0x12, 0x0, 0x7, 0x0, 0x2c, 0x0, 0x2e, 0x2, 0x1b, 0x0, 0x2c, 0x0, 0x38, 0x0, 0x17, 0x0, 0x10, 0x0, 0x13, 0x0, 0x38, 0x0, 0x16, 0x0, 0x8, 0x0, 0x17, 0x0, 0x18, 0x0, 0x13, 0x0, 0x2d, 0x2, 0x10, 0x0, 0x4, 0x0, 0x6, 0x0, 0x37, 0x0, 0x16, 0x0, 0xb, 0x0, 0x28, 0x0, 0x38, 0x0, 0x17, 0x0, 0x10, 0x0, 0x13, 0x0, 0x38, 0x0, 0x16, 0x0, 0x8, 0x0, 0x17, 0x0, 0x18, 0x0, 0x13, 0x0, 0x2d, 0x2, 0x10, 0x0, 0x4, 0x0, 0x6, 0x0, 0x37, 0x0, 0x16, 0x0, 0xb, 0x0, 0x2c, 0x0, 0x2d, 0x0, 0xb, 0x0, 0x2c, 0x0, 0x10, 0x0, 0x4, 0x0, 0x6, 0x0, 0x5, 0x0, 0x12, 0x0, 0x12, 0x0, 0xe, 0x0, 0x27, 0x0
    },
    // de-CH
    {
      0x2c, 0x8, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, // COMMAND + SPACE, delay 3 * 255ms
      0x17, 0x2, 0x8, 0x0, 0x15, 0x0, 0x10, 0x0, 0xc, 0x0, 0x11, 0x0, 0x4, 0x0, 0xf, 0x0, 0x0, 0xff, 0x0, 0xff, // "Terminal", delay 2 * 255ms
      0x28, 0x0, 0x0, 0xff, 0x0, 0xff, // ENTER, delay 2 * 255ms
      0x6, 0x0, 0x18, 0x0, 0x15, 0x0, 0xf, 0x0, 0x2c, 0x0, 0xb, 0x0, 0x17, 0x0, 0x17, 0x0, 0x13, 0x0, 0x16, 0x0, 0x37, 0x2, 0x24, 0x2, 0x24, 0x2, 0x13, 0x0, 0x4, 0x0, 0x6, 0x0, 0xe, 0x0, 0x4, 0x0, 0xa, 0x0, 0x8, 0x0, 0x16, 0x0, 0x38, 0x0, 0xf, 0x0, 0xc, 0x0, 0x11, 0x0, 0x18, 0x0, 0x1b, 0x0, 0x37, 0x0, 0xf, 0x0, 0x1c, 0x0, 0xf, 0x0, 0x4, 0x0, 0x5, 0x0, 0x16, 0x0, 0x37, 0x0, 0x6, 0x0, 0x12, 0x0, 0x10, 0x0, 0x24, 0x2, 0xf, 0x2, 0x1c, 0x0, 0xf, 0x2, 0x4, 0x0, 0x5, 0x0, 0x16, 0x0, 0x24, 0x2, 0x4, 0x2, 0x11, 0x0, 0x16, 0x0, 0xc, 0x0, 0x5, 0x0, 0xf, 0x0, 0x8, 0x0, 0x24, 0x2, 0x16, 0x0, 0x8, 0x0, 0x17, 0x0, 0x18, 0x0, 0x13, 0x0, 0x38, 0x2, 0x10, 0x0, 0x4, 0x0, 0x6, 0x0, 0x37, 0x0, 0x16, 0x0, 0xb, 0x0, 0x2c, 0x0, 0x38, 0x0, 0x12, 0x0, 0x2c, 0x0, 0x24, 0x2, 0x17, 0x0, 0x10, 0x0, 0x13, 0x0, 0x24, 0x2, 0x16, 0x0, 0x8, 0x0, 0x17, 0x0, 0x18, 0x0, 0x13, 0x0, 0x38, 0x2, 0x10, 0x0, 0x4, 0x0, 0x6, 0x0, 0x37, 0x0, 0x16, 0x0, 0xb, 0x0, 0x28, 0x0, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0x0, 0x6, 0x0, 0xb, 0x0, 0x10, 0x0, 0x12, 0x0, 0x7, 0x0, 0x2c, 0x0, 0x1e, 0x2, 0x1b, 0x0, 0x2c, 0x0, 0x24, 0x2, 0x17, 0x0, 0x10, 0x0, 0x13, 0x0, 0x24, 0x2, 0x16, 0x0, 0x8, 0x0, 0x17, 0x0, 0x18, 0x0, 0x13, 0x0, 0x38, 0x2, 0x10, 0x0, 0x4, 0x0, 0x6, 0x0, 0x37, 0x0, 0x16, 0x0, 0xb, 0x0, 0x28, 0x0, 0x24, 0x2, 0x17, 0x0, 0x10, 0x0, 0x13, 0x0, 0x24, 0x2, 0x16, 0x0, 0x8, 0x0, 0x17, 0x0, 0x18, 0x0, 0x13, 0x0, 0x38, 0x2, 0x10, 0x0, 0x4, 0x0, 0x6, 0x0, 0x37, 0x0, 0x16, 0x0, 0xb, 0x0, 0x2c, 0x0, 0x38, 0x0, 0xb, 0x0, 0x2c, 0x0, 0x10, 0x0, 0x4, 0x0, 0x6, 0x0, 0x5, 0x0, 0x12, 0x0, 0x12, 0x0, 0xe, 0x0, 0x27, 0x0
    }
  }/*,
  // Windows provisioning
  {
    // en-US
    {
      KEY_R, MOD_GUI_LEFT, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, // WINDOWS + R, , delay 10 * 255ms
      0x13, 0x0, 0x12, 0x0, 0x1a, 0x0, 0x8, 0x0, 0x15, 0x0, 0x16, 0x0, 0xb, 0x0, 0x8, 0x0, 0xf, 0x0, 0xf, 0x0, 0x2c, 0x0, 0x16, 0x2, 0x17, 0x0, 0x4, 0x0, 0x15, 0x0, 0x17, 0x0, 0x2d, 0x0, 0x13, 0x2, 0x15, 0x0, 0x12, 0x0, 0x6, 0x0, 0x8, 0x0, 0x16, 0x0, 0x16, 0x0, 0x2c, 0x0, 0x13, 0x0, 0x12, 0x0, 0x1a, 0x0, 0x8, 0x0, 0x15, 0x0, 0x16, 0x0, 0xb, 0x0, 0x8, 0x0, 0xf, 0x0, 0xf, 0x0, 0x2c, 0x0, 0x2d, 0x0, 0x19, 0x2, 0x8, 0x0, 0x15, 0x0, 0x5, 0x0, 0x2c, 0x0, 0x15, 0x0, 0x18, 0x0, 0x11, 0x0, 0x4, 0x2, 0x16, 0x0, 0x28, 0x0, 0x50, 0x0, 0x28, 0x0, 0x13, 0x0, 0x12, 0x0, 0x1a, 0x0, 0x8, 0x0, 0x15, 0x0, 0x16, 0x0, 0xb, 0x0, 0x8, 0x0, 0xf, 0x0, 0xf, 0x0, 0x2c, 0x0, 0x2d, 0x0, 0x11, 0x2, 0x12, 0x0, 0x13, 0x2, 0x2c, 0x0, 0x2d, 0x0, 0x11, 0x2, 0x12, 0x0, 0x8, 0x2, 0x2c, 0x0, 0x2d, 0x0, 0x8, 0x2, 0x1b, 0x0, 0x8, 0x0, 0x6, 0x0, 0x2c, 0x0, 0x5, 0x2, 0x1c, 0x0, 0x13, 0x0, 0x4, 0x0, 0x16, 0x0, 0x16, 0x0, 0x2c, 0x0, 0x2d, 0x0, 0x9, 0x2, 0xc, 0x0, 0xf, 0x0, 0x8, 0x0, 0x2c, 0x0, 0x34, 0x2, 0x31, 0x0, 0x31, 0x0, 0x9, 0x0, 0xc, 0x0, 0xf, 0x0, 0x8, 0x0, 0x27, 0x0, 0x1e, 0x0, 0x37, 0x0, 0xf, 0x0, 0x1d, 0x0, 0xf, 0x0, 0x4, 0x0, 0x5, 0x0, 0x16, 0x0, 0x37, 0x0, 0x6, 0x0, 0xb, 0x0, 0x31, 0x0, 0x16, 0x0, 0x12, 0x0, 0x9, 0x0, 0x17, 0x0, 0x1a, 0x0, 0x4, 0x0, 0x15, 0x0, 0x8, 0x0, 0x31, 0x0, 0x15, 0x2, 0x8, 0x0, 0x7, 0x0, 0x2c, 0x0, 0xb, 0x2, 0x4, 0x0, 0x17, 0x0, 0x31, 0x0, 0x4, 0x2, 0x11, 0x0, 0x16, 0x0, 0xc, 0x0, 0x5, 0x0, 0xf, 0x0, 0x8, 0x0, 0x31, 0x0, 0x16, 0x0, 0x8, 0x0, 0x17, 0x0, 0x18, 0x0, 0x13, 0x0, 0x2d, 0x2, 0x1a, 0x0, 0xc, 0x0, 0x11, 0x0, 0x15, 0x0, 0x10, 0x0, 0x37, 0x0, 0x13, 0x0, 0x16, 0x0, 0x1e, 0x0, 0x34, 0x2, 0x28, 0x0, 0x16, 0x2, 0x8, 0x0, 0x17, 0x0, 0x2d, 0x0, 0xc, 0x2, 0x17, 0x0, 0x8, 0x0, 0x10, 0x0, 0x2c, 0x0, 0x2d, 0x0, 0x13, 0x2, 0x4, 0x0, 0x17, 0x0, 0xb, 0x0, 0x2c, 0x0, 0x34, 0x2, 0x1a, 0x2, 0x16, 0x2, 0x10, 0x2, 0x4, 0x2, 0x11, 0x2, 0x33, 0x2, 0x31, 0x0, 0xf, 0x0, 0x12, 0x0, 0x6, 0x0, 0x4, 0x0, 0xf, 0x0, 0xb, 0x0, 0x12, 0x0, 0x16, 0x0, 0x17, 0x0, 0x31, 0x0, 0x16, 0x2, 0x8, 0x0, 0x15, 0x0, 0x19, 0x0, 0xc, 0x0, 0x6, 0x0, 0x8, 0x0, 0x31, 0x0, 0x4, 0x2, 0xf, 0x0, 0xf, 0x0, 0x12, 0x0, 0x1a, 0x0, 0x18, 0x2, 0x11, 0x0, 0x8, 0x0, 0x11, 0x0, 0x6, 0x0, 0x15, 0x0, 0x1c, 0x0, 0x13, 0x0, 0x17, 0x0, 0x8, 0x0, 0x7, 0x0, 0x34, 0x2, 0x2c, 0x0, 0x2d, 0x0, 0x19, 0x2, 0x4, 0x0, 0xf, 0x0, 0x18, 0x0, 0x8, 0x0, 0x2c, 0x0, 0x21, 0x2, 0x17, 0x0, 0x15, 0x0, 0x18, 0x0, 0x8, 0x0, 0x28, 0x0
    },
    // de-CH
    {
      KEY_R, MOD_GUI_LEFT, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, // WINDOWS + R, , delay 10 * 255ms
      0x13, 0x0, 0x12, 0x0, 0x1a, 0x0, 0x8, 0x0, 0x15, 0x0, 0x16, 0x0, 0xb, 0x0, 0x8, 0x0, 0xf, 0x0, 0xf, 0x0, 0x2c, 0x0, 0x16, 0x2, 0x17, 0x0, 0x4, 0x0, 0x15, 0x0, 0x17, 0x0, 0x2d, 0x0, 0x13, 0x2, 0x15, 0x0, 0x12, 0x0, 0x6, 0x0, 0x8, 0x0, 0x16, 0x0, 0x16, 0x0, 0x2c, 0x0, 0x13, 0x0, 0x12, 0x0, 0x1a, 0x0, 0x8, 0x0, 0x15, 0x0, 0x16, 0x0, 0xb, 0x0, 0x8, 0x0, 0xf, 0x0, 0xf, 0x0, 0x2c, 0x0, 0x2d, 0x0, 0x19, 0x2, 0x8, 0x0, 0x15, 0x0, 0x5, 0x0, 0x2c, 0x0, 0x15, 0x0, 0x18, 0x0, 0x11, 0x0, 0x4, 0x2, 0x16, 0x0, 0x28, 0x0, 0x50, 0x0, 0x28, 0x0, 0x13, 0x0, 0x12, 0x0, 0x1a, 0x0, 0x8, 0x0, 0x15, 0x0, 0x16, 0x0, 0xb, 0x0, 0x8, 0x0, 0xf, 0x0, 0xf, 0x0, 0x2c, 0x0, 0x2d, 0x0, 0x11, 0x2, 0x12, 0x0, 0x13, 0x2, 0x2c, 0x0, 0x2d, 0x0, 0x11, 0x2, 0x12, 0x0, 0x8, 0x2, 0x2c, 0x0, 0x2d, 0x0, 0x8, 0x2, 0x1b, 0x0, 0x8, 0x0, 0x6, 0x0, 0x2c, 0x0, 0x5, 0x2, 0x1c, 0x0, 0x13, 0x0, 0x4, 0x0, 0x16, 0x0, 0x16, 0x0, 0x2c, 0x0, 0x2d, 0x0, 0x9, 0x2, 0xc, 0x0, 0xf, 0x0, 0x8, 0x0, 0x2c, 0x0, 0x34, 0x2, 0x31, 0x0, 0x31, 0x0, 0x9, 0x0, 0xc, 0x0, 0xf, 0x0, 0x8, 0x0, 0x27, 0x0, 0x1e, 0x0, 0x37, 0x0, 0xf, 0x0, 0x1d, 0x0, 0xf, 0x0, 0x4, 0x0, 0x5, 0x0, 0x16, 0x0, 0x37, 0x0, 0x6, 0x0, 0xb, 0x0, 0x31, 0x0, 0x16, 0x0, 0x12, 0x0, 0x9, 0x0, 0x17, 0x0, 0x1a, 0x0, 0x4, 0x0, 0x15, 0x0, 0x8, 0x0, 0x31, 0x0, 0x15, 0x2, 0x8, 0x0, 0x7, 0x0, 0x2c, 0x0, 0xb, 0x2, 0x4, 0x0, 0x17, 0x0, 0x31, 0x0, 0x4, 0x2, 0x11, 0x0, 0x16, 0x0, 0xc, 0x0, 0x5, 0x0, 0xf, 0x0, 0x8, 0x0, 0x31, 0x0, 0x16, 0x0, 0x8, 0x0, 0x17, 0x0, 0x18, 0x0, 0x13, 0x0, 0x2d, 0x2, 0x1a, 0x0, 0xc, 0x0, 0x11, 0x0, 0x15, 0x0, 0x10, 0x0, 0x37, 0x0, 0x13, 0x0, 0x16, 0x0, 0x1e, 0x0, 0x34, 0x2, 0x28, 0x0, 0x16, 0x2, 0x8, 0x0, 0x17, 0x0, 0x2d, 0x0, 0xc, 0x2, 0x17, 0x0, 0x8, 0x0, 0x10, 0x0, 0x2c, 0x0, 0x2d, 0x0, 0x13, 0x2, 0x4, 0x0, 0x17, 0x0, 0xb, 0x0, 0x2c, 0x0, 0x34, 0x2, 0x1a, 0x2, 0x16, 0x2, 0x10, 0x2, 0x4, 0x2, 0x11, 0x2, 0x33, 0x2, 0x31, 0x0, 0xf, 0x0, 0x12, 0x0, 0x6, 0x0, 0x4, 0x0, 0xf, 0x0, 0xb, 0x0, 0x12, 0x0, 0x16, 0x0, 0x17, 0x0, 0x31, 0x0, 0x16, 0x2, 0x8, 0x0, 0x15, 0x0, 0x19, 0x0, 0xc, 0x0, 0x6, 0x0, 0x8, 0x0, 0x31, 0x0, 0x4, 0x2, 0xf, 0x0, 0xf, 0x0, 0x12, 0x0, 0x1a, 0x0, 0x18, 0x2, 0x11, 0x0, 0x8, 0x0, 0x11, 0x0, 0x6, 0x0, 0x15, 0x0, 0x1c, 0x0, 0x13, 0x0, 0x17, 0x0, 0x8, 0x0, 0x7, 0x0, 0x34, 0x2, 0x2c, 0x0, 0x2d, 0x0, 0x19, 0x2, 0x4, 0x0, 0xf, 0x0, 0x18, 0x0, 0x8, 0x0, 0x2c, 0x0, 0x21, 0x2, 0x17, 0x0, 0x15, 0x0, 0x18, 0x0, 0x8, 0x0, 0x28, 0x0
    }
  }*/
};
static uint8_t menu3_last_len = 0;
static uint8_t menu3_selection = 0;

void setup() {
  // set pins as input with internal pull-up resistors enabled
  pinMode(PIN_ENCODER_A, INPUT);
  pinMode(PIN_ENCODER_B, INPUT);
  digitalWrite(PIN_ENCODER_A, HIGH);
  digitalWrite(PIN_ENCODER_B, HIGH);

  pinMode(PIN_ENCODER_SWITCH, INPUT);
  // the switch is active-high, not active-low
  // since it shares the pin with DigiSpark's built-in LED
  // the LED acts as a pull-down resistor
  digitalWrite(PIN_ENCODER_SWITCH, LOW);

  // get an initial reading on the encoder pins
  if (digitalRead(PIN_ENCODER_A) == LOW) {
    enc_prev_pos |= (1 << 0);
  }
  if (digitalRead(PIN_ENCODER_B) == LOW) {
    enc_prev_pos |= (1 << 1);
  }

  // this is generally not necessary but with some older systems it seems to
  // prevent missing the first character after a delay:
  DigiKeyboard.sendKeyStroke(0);
  DigiKeyboard.delay(250);
}

void loop() {
  switch(state) {
    // wait until a click signals that the user is ready
    case 0:
      if (is_clicked()) {
        // only ask once about keyboard and pin
        if (menu2_count == PIN_LEN) {
          state = 3;
          menu3_print();
        } else {
          ++state;
          menu1_print();
        }
      }
      break;

    // keyboard layout selection
    case 1:
      read_direction();
      if (is_up() || is_down()) {
        // lang = (lang == 0) ? 1 : 0;
        lang = lang ^ (1<<0);
        menu_delete(SEPARATOR_LEN + (MENU1_OPTIONS_LEN / 2));
        menu1_selection_print();
      }
      if (is_clicked()) {
        ++state;
        menu_delete(MENU1_LEN + SEPARATOR_LEN + (MENU1_OPTIONS_LEN / 2));
        menu2_print();
      }
      break;

    // pin code
    case 2:
      read_direction();
      if (is_up() || is_down()) {
        if (is_up()) {
          ++menu2_selection;
          if (menu2_selection > 9) {
            menu2_selection = 0;
          }
        } else {
          --menu2_selection;
          if (menu2_selection > 9) {
            menu2_selection = 9;
          }
        }
        menu_delete(1);
        menu2_selection_print();
      }
      if (is_clicked()) {
        if (pin[menu2_count] == menu2_selection) {
          menu2_selection = 0;
          ++menu2_count;
          if (menu2_count < PIN_LEN) {
            menu2_selection_print();
          }
        }
      }
      if (menu2_count == PIN_LEN) {
        ++state;
        menu_delete(MENU2_LEN + SEPARATOR_LEN + menu2_count + 1);
        menu3_print();
      }
      break;

    // keystroke sequence selection
    case 3:
      read_direction();
      if (is_up() || is_down()) {
        if (is_up()) {
          ++menu3_selection;
          if (menu3_selection >= MENU3_LEN) {
            menu3_selection = 0;
          }
        } else {
          --menu3_selection;
          if (menu3_selection >= MENU3_LEN) {
            menu2_selection = MENU3_LEN;
          }
        }
        menu_delete(menu3_last_len);
        menu3_print();
      }
      if (is_clicked()) {
        ++state;
        menu_delete(menu3_last_len);
        menu3_selection_print();
      }
      break;

    default:
      state = 0;
      DigiKeyboard.delay(245);
      break;
  }

  DigiKeyboard.delay(5);
}

void menu1_print() {
  // keyboard
  for (uint8_t i = 0; i < MENU1_LEN; ++i) {
    uint8_t key = pgm_read_byte_near(menu1 + i);
    DigiKeyboard.sendKeyStroke(key);
  }
  menu1_selection_print();
}

void menu1_selection_print() {
  menu_separator_print();
  // current language
  for (uint8_t i = (lang ? (MENU1_OPTIONS_LEN / 2) : 0); i < (lang ? MENU1_OPTIONS_LEN : (MENU1_OPTIONS_LEN / 2)); ++i) {
    uint8_t key = pgm_read_byte_near(menu1_options + i);
    DigiKeyboard.sendKeyStroke(key, ((i > (lang ? MENU1_OPTIONS_LEN : (MENU1_OPTIONS_LEN / 2)) - 3) ? MOD_SHIFT_LEFT : 0x0));
  }
}

void menu2_print() {
  // pin
  for (uint8_t i = 0; i < MENU2_LEN; ++i) {
    uint8_t key = pgm_read_byte_near(menu2 + i);
    DigiKeyboard.sendKeyStroke(key);
  }
  menu_separator_print();
  menu2_selection_print();
}

void menu2_selection_print() {
  DigiKeyboard.sendKeyStroke(0x1d + (menu2_selection == 0 ? 10 : menu2_selection));
}

void menu3_print() {
    uint16_t mem_address = ((uint16_t) menu3_labels) + (lang * MENU3_LABEL_LEN) + (menu3_selection * MENU3_LABEL_LEN * 2);
    uint8_t i = 0;
    for (; i < MENU3_LABEL_LEN; ++i) {
      uint8_t key = pgm_read_byte_near(mem_address + i);
      if (key > 0) {
        DigiKeyboard.sendKeyStroke(key);
      } else {
        break;
      }
    }
    menu3_last_len = i;
}

void menu3_selection_print() {
    uint16_t mem_address = ((uint16_t) menu3_keys) + (lang * MENU3_KEY_LEN) + (menu3_selection * MENU3_KEY_LEN * 2);
    for (uint8_t i = 0; i < MENU3_KEY_LEN; i += 2) {
      uint8_t key = pgm_read_byte_near(mem_address + i);
      uint8_t mod = pgm_read_byte_near(mem_address + i + 1);
      if (key == 0) {
        if (mod > 0) {
          DigiKeyboard.delay(mod);
        } else {
          break;
        }
      } else {
        DigiKeyboard.sendKeyStroke(key, mod);
      }
    }
}

void menu_separator_print() {
  // [:] in de-CH or en-US
  DigiKeyboard.sendKeyStroke(lang ? 0x37 : 0x33, MOD_SHIFT_LEFT);
  // [space]
  DigiKeyboard.sendKeyStroke(0x2c);
}

void menu_delete(uint8_t count) {
  for (uint8_t i = 0; i < count; ++i) {
    // [backspace]
    DigiKeyboard.sendKeyStroke(0x2a);
  }
}

void read_direction() {
  enc_action = 0; // reset
  uint8_t enc_cur_pos = 0;

  // read in the encoder state first
  if (!digitalRead(PIN_ENCODER_A)) {
    enc_cur_pos |= (1 << 0);
  }
  if (!digitalRead(PIN_ENCODER_B)) {
    enc_cur_pos |= (1 << 1);
  }

  // if any rotation at all
  if (enc_cur_pos != enc_prev_pos) {
    if (enc_prev_pos == 0x00) {
      // this is the first edge
      if (enc_cur_pos == 0x01) {
        enc_flags |= (1 << 0);
      } else if (enc_cur_pos == 0x02) {
        enc_flags |= (1 << 1);
      }
    }

    if (enc_cur_pos == 0x03) {
      // this is when the encoder is in the middle of a "step"
      enc_flags |= (1 << 4);
    } else if (enc_cur_pos == 0x00) {
      // this is the final edge
      if (enc_prev_pos == 0x02) {
        enc_flags |= (1 << 2);
      }
      else if (enc_prev_pos == 0x01) {
        enc_flags |= (1 << 3);
      }
 
      // check the first and last edge
      // or maybe one edge is missing, if missing then require the middle state
      // this will reject bounces and false movements
      if (bit_is_set(enc_flags, 0) && (bit_is_set(enc_flags, 2) || bit_is_set(enc_flags, 4))) {
        enc_action = 1;
      } else if (bit_is_set(enc_flags, 2) && (bit_is_set(enc_flags, 0) || bit_is_set(enc_flags, 4))) {
        enc_action = 1;
      } else if (bit_is_set(enc_flags, 1) && (bit_is_set(enc_flags, 3) || bit_is_set(enc_flags, 4))) {
        enc_action = -1;
      } else if (bit_is_set(enc_flags, 3) && (bit_is_set(enc_flags, 1) || bit_is_set(enc_flags, 4))) {
        enc_action = -1;
      }
      enc_flags = 0; // reset for next time
    }
  }
 
  enc_prev_pos = enc_cur_pos;
}

bool is_up() {
  return enc_action > 0;
}

bool is_down() {
  return enc_action < 0;
}

bool is_clicked() {
  return digitalRead(PIN_ENCODER_SWITCH);
}

